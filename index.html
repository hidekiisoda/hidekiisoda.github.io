<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="dark" />
<title>Dr. Hideki Isoda</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#031225;}
  canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;}
  .site-link{
    position:fixed; right:18px; bottom:16px; z-index:10;
    font: 11px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    letter-spacing:.08em; text-transform:uppercase;
    pointer-events:auto;
  }
  .site-link a{
    color:rgba(245,250,255,.82);
    text-decoration:none;
    border-bottom:1px solid rgba(245,250,255,.35);
    padding-bottom:2px;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,.45));
  }
  .site-link a:hover{
    color:rgba(255,255,255,.98);
    border-bottom-color:rgba(255,255,255,.75);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="site-link">
  <a href="https://hidekiisoda.com" target="_blank" rel="noopener">hidekiisoda.com</a>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const gl =
    canvas.getContext("webgl", { alpha:false, antialias:false, preserveDrawingBuffer:false }) ||
    canvas.getContext("experimental-webgl", { alpha:false, antialias:false, preserveDrawingBuffer:false });

  // Functional fallback: bright ocean gradient (no extra text)
  if (!gl) {
    const ctx = canvas.getContext("2d");
    const resize2D = () => {
      const dpr = Math.min(2, devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth*dpr);
      canvas.height = Math.floor(innerHeight*dpr);
      canvas.style.width = innerWidth+"px";
      canvas.style.height = innerHeight+"px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const g = ctx.createLinearGradient(0,0,0,innerHeight);
      g.addColorStop(0, "#3fe6ff");
      g.addColorStop(0.35, "#1fb4ff");
      g.addColorStop(0.7, "#0b4d9f");
      g.addColorStop(1, "#031225");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,innerWidth,innerHeight);
    };
    addEventListener("resize", resize2D, {passive:true}); resize2D();
    return;
  }

  const VERT = `
    attribute vec2 aPos;
    varying vec2 vUv;
    void main(){
      vUv = aPos*0.5 + 0.5;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;

  // BRIGHT ocean + waterfall spectrogram aesthetic:
  // - domain-warped fbm waves (ocean motion)
  // - flowing “waterfall” streaks (sound analysis vibe)
  // - bright palette + bloom-ish highlights (without postprocess)
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2  iResolution;
    uniform float iTime;
    uniform vec2  iMouse;

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f*f*(3.0-2.0*f);
      float a = hash12(i);
      float b = hash12(i + vec2(1.0,0.0));
      float c = hash12(i + vec2(0.0,1.0));
      float d = hash12(i + vec2(1.0,1.0));
      return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
    }

    float fbm(vec2 p){
      float v = 0.0;
      float a = 0.55;
      mat2 m = mat2(1.62, 1.18, -1.18, 1.62);
      for(int i=0;i<6;i++){
        v += a * noise(p);
        p = m*p + 0.12;
        a *= 0.5;
      }
      return v;
    }

    // Smooth ocean palette (bright)
    vec3 oceanPal(float t){
      // t in [0,1]
      vec3 deep  = vec3(0.02, 0.10, 0.22);
      vec3 mid   = vec3(0.05, 0.35, 0.80);
      vec3 aqua  = vec3(0.20, 0.85, 0.95);
      vec3 foam  = vec3(0.95, 0.98, 1.00);
      vec3 c = mix(deep, mid, smoothstep(0.0, 0.55, t));
      c = mix(c, aqua, smoothstep(0.35, 0.80, t));
      c = mix(c, foam, smoothstep(0.78, 1.00, t));
      return c;
    }

    mat2 rot(float a){
      float s = sin(a), c = cos(a);
      return mat2(c,-s,s,c);
    }

    void main(){
      vec2 res = iResolution;
      vec2 uv = vUv;
      vec2 p = (uv*2.0 - 1.0);
      p.x *= res.x / max(1.0,res.y);

      // smoothed mouse steering (passed as smoothed)
      vec2 m = iMouse / max(res, vec2(1.0));
      vec2 steer = (m - 0.5);

      float t = iTime;

      // --- Ocean surface field (domain warped)
      vec2 q = p;
      q = rot(0.06*sin(t*0.35)) * q;

      // warp for fluid motion
      float wA = fbm(q*1.25 + vec2(0.18*t, -0.10*t));
      float wB = fbm(q*2.20 + vec2(-0.14*t, 0.16*t));
      vec2 warp = vec2(wA-0.5, wB-0.5);
      q += warp * 0.85;

      // primary wave height (smooth)
      float h1 = sin(q.x*2.2 + t*1.25);
      float h2 = sin(q.x*3.8 - t*0.95 + warp.y*2.0);
      float h3 = sin((q.x+q.y*0.35)*6.2 + t*1.65);
      float height = 0.52 + 0.22*h1 + 0.16*h2 + 0.10*h3 + 0.30*(wA-0.5);

      // "swell" increases toward bottom (like a waterfall spectrogram panel)
      float swell = smoothstep(0.10, 1.0, uv.y);
      height += swell * 0.18 * sin((q.y*3.2 - t*1.8) + warp.x*2.0);

      // --- Waterfall / spectrogram streaks (vertical energy trails)
      // Build vertical ridges with time flow, then soften.
      vec2 s = q;
      s.x += (wB-0.5) * 0.65;
      float streakBase = sin((s.x*10.0 + fbm(s*2.4)*2.8) + t*2.6);
      float streaks = 0.5 + 0.5*streakBase;
      streaks = pow(streaks, 3.2);                  // thin bright ridges
      streaks *= smoothstep(0.05, 0.95, uv.y);      // waterfall emerges downward

      // add micro streaks (finer analysis lines)
      float micro = 0.5 + 0.5*sin((s.x*22.0 + fbm(s*4.2)*3.4) + t*4.2);
      micro = pow(micro, 7.0) * 0.65;

      // --- Foam / highlight = where gradients change (pseudo-derivative)
      float e = 0.0025;
      float heightX = (0.52 + 0.22*sin((q.x+e)*2.2 + t*1.25)
                      +0.16*sin((q.x+e)*3.8 - t*0.95 + warp.y*2.0)
                      +0.10*sin(((q.x+e)+q.y*0.35)*6.2 + t*1.65)
                      +0.30*(wA-0.5));
      float slope = abs(heightX - height);
      float foam = smoothstep(0.035, 0.12, slope);
      foam += smoothstep(0.35, 0.98, streaks) * 0.65;
      foam += micro * 0.45;

      // --- Shading: brighter overall
      // Base brightness uses height + vertical light gradient
      float light = 0.55 + 0.55*(1.0-uv.y) + 0.30*height;
      // Cursor subtly “conducts” energy
      float focus = exp(-4.8*dot(steer,steer));
      light += focus * 0.18;

      // Color from height (ocean) + spectrogram streak energy
      float tone = clamp(0.45 + 0.75*height + 0.55*streaks, 0.0, 1.0);
      vec3 col = oceanPal(tone);

      // Add bright waterfall glow
      col += vec3(0.20, 0.70, 0.95) * streaks * 0.55;
      col += vec3(0.85, 0.95, 1.00) * micro * 0.30;

      // Foam highlights
      col = mix(col, vec3(0.95,0.99,1.00), clamp(foam,0.0,1.0));

      // Subtle sunbeam gradient at top
      vec3 sky = vec3(0.25, 0.95, 1.00);
      float topGlow = smoothstep(0.0, 0.28, 1.0-uv.y);
      col = mix(col, sky, topGlow * 0.20);

      // Contrast + brightness lift (avoid “too dark”)
      col *= light;
      col = pow(col, vec3(0.86)); // gamma lift -> brighter

      // Vignette (very light, keeps edges clean but not dark)
      vec2 vv = (uv*2.0-1.0)*vec2(res.x/max(1.0,res.y),1.0);
      float vig = smoothstep(1.7, 0.55, dot(vv,vv));
      col *= (0.92 + 0.14*vig);

      // Dither (tiny)
      float d = (hash12(gl_FragCoord.xy + t*13.0)-0.5)/255.0;
      col += d;

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      gl.deleteProgram(p);
      return null;
    }
    return p;
  }

  const vs = compile(gl.VERTEX_SHADER, VERT);
  const fs = compile(gl.FRAGMENT_SHADER, FRAG);
  if(!vs || !fs) return;

  const prog = link(vs, fs);
  if(!prog) return;
  gl.useProgram(prog);

  // Fullscreen quad
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog, "aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  const uRes   = gl.getUniformLocation(prog, "iResolution");
  const uTime  = gl.getUniformLocation(prog, "iTime");
  const uMouse = gl.getUniformLocation(prog, "iMouse");

  // Resize
  let DPR=1, w=0, h=0;
  function resize(){
    DPR = Math.min(2, devicePixelRatio || 1);
    w = Math.floor(innerWidth * DPR);
    h = Math.floor(innerHeight * DPR);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0, 0, w, h);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // Mouse smoothing
  let mx = innerWidth*0.5, my = innerHeight*0.5;
  let smx = mx, smy = my;
  addEventListener("pointermove", (e)=>{ mx=e.clientX; my=e.clientY; }, {passive:true});

  let t0 = performance.now();
  function draw(now){
    requestAnimationFrame(draw);

    smx += (mx - smx) * 0.10;
    smy += (my - smy) * 0.10;

    const t = (now - t0) / 1000;

    gl.uniform2f(uRes, w, h);
    gl.uniform1f(uTime, t);

    // flip Y
    gl.uniform2f(uMouse, smx * DPR, (innerHeight - smy) * DPR);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="dark" />
<title>Dr. Hideki Isoda</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#05060a;}
  canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;}
  .site-link{
    position:fixed; right:18px; bottom:16px; z-index:10;
    font: 11px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    letter-spacing:.08em; text-transform:uppercase;
    pointer-events:auto;
  }
  .site-link a{
    color:rgba(200,220,255,.70);
    text-decoration:none;
    border-bottom:1px solid rgba(200,220,255,.28);
    padding-bottom:2px;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,.55));
  }
  .site-link a:hover{
    color:rgba(255,255,255,.92);
    border-bottom-color:rgba(255,255,255,.65);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="site-link">
  <a href="https://hidekiisoda.com" target="_blank" rel="noopener">hidekiisoda.com</a>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");

  // --- WebGL setup (fast + smooth fractal animation)
  const gl = canvas.getContext("webgl2", { antialias: false, alpha: false, desynchronized: true })
        || canvas.getContext("webgl",  { antialias: false, alpha: false, desynchronized: true });

  if (!gl) {
    // Minimal fallback: static gradient (keeps page functional)
    const ctx = canvas.getContext("2d");
    const resize = () => {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width = innerWidth + "px";
      canvas.style.height = innerHeight + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const g = ctx.createRadialGradient(innerWidth*0.35, innerHeight*0.25, 0, innerWidth*0.5, innerHeight*0.5, Math.max(innerWidth,innerHeight));
      g.addColorStop(0, "#141a3a"); g.addColorStop(0.45, "#0b0f22"); g.addColorStop(1, "#05060a");
      ctx.fillStyle = g; ctx.fillRect(0,0,innerWidth,innerHeight);
    };
    addEventListener("resize", resize, {passive:true}); resize();
    return;
  }

  const isWebGL2 = (gl instanceof WebGL2RenderingContext);

  const VERT = `
    attribute vec2 aPos;
    varying vec2 vUv;
    void main(){
      vUv = aPos*0.5 + 0.5;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;

  // Smooth, animated fractal (Julia set) + fbm warping + audio-like interference sheets (abstract)
  const FRAG = (isWebGL2 ? `#version 300 es
    precision highp float;
    out vec4 outColor;
    in vec2 vUv;
    uniform vec2 iResolution;
    uniform float iTime;
    uniform vec2 iMouse;
  ` : `
    precision highp float;
    varying vec2 vUv;
    uniform vec2 iResolution;
    uniform float iTime;
    uniform vec2 iMouse;
  `) + `

    // --- Hash / noise / fbm (fractal)
    float hash21(vec2 p){
      p = fract(p*vec2(123.34, 345.45));
      p += dot(p, p+34.345);
      return fract(p.x*p.y);
    }

    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f*f*(3.0-2.0*f);
      float a = hash21(i);
      float b = hash21(i + vec2(1.0,0.0));
      float c = hash21(i + vec2(0.0,1.0));
      float d = hash21(i + vec2(1.0,1.0));
      return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
    }

    float fbm(vec2 p){
      float v = 0.0;
      float a = 0.52;
      mat2 m = mat2(1.62, 1.21, -1.21, 1.62);
      for(int i=0;i<5;i++){
        v += a * noise(p);
        p = m*p + 0.11;
        a *= 0.5;
      }
      return v;
    }

    mat2 rot(float a){
      float s = sin(a), c = cos(a);
      return mat2(c,-s,s,c);
    }

    // Smooth palette
    vec3 palette(float t){
      vec3 a = vec3(0.10, 0.12, 0.20);
      vec3 b = vec3(0.55, 0.45, 0.75);
      vec3 c = vec3(1.10, 1.00, 0.90);
      vec3 d = vec3(0.20, 0.32, 0.55);
      return a + b*cos(6.28318*(c*t + d));
    }

    // Julia fractal with smooth iteration count
    float julia(vec2 z, vec2 c){
      float it = 0.0;
      float m2 = dot(z,z);
      for(int i=0;i<140;i++){
        // z = z^2 + c
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        m2 = dot(z,z);
        if(m2 > 16.0){
          it = float(i);
          break;
        }
        it = float(i);
      }
      // smooth iteration
      float mu = it;
      if(m2 > 0.0){
        mu = it - log2(log2(max(1.0001, m2)));
      }
      return mu;
    }

    void main(){
      vec2 res = iResolution;
      vec2 uv = (vUv*2.0 - 1.0);
      uv.x *= res.x / res.y;

      // Mouse: subtle steering, never jittery
      vec2 m = (iMouse / max(res, vec2(1.0)));
      vec2 steer = (m - 0.5) * vec2(0.35, 0.25);

      float t = iTime;

      // Global gentle zoom + rotation (kept smooth, not slow)
      float zoom = 1.55 + 0.18*sin(t*0.55);
      uv *= zoom;
      uv = rot(0.22*sin(t*0.25) + 0.10*cos(t*0.17)) * uv;

      // Fractal warp (fbm) for 3D-ish depth illusion
      float w1 = fbm(uv*1.05 + vec2(0.0, t*0.22));
      float w2 = fbm(uv*1.90 + vec2(t*0.12, 0.0));
      vec2 warp = vec2(w1 - 0.5, w2 - 0.5);
      uv += warp * (0.42 + 0.18*sin(t*0.35));

      // Julia parameter c animates on a small loop (stable, smooth)
      vec2 c = vec2(-0.745, 0.132);
      c += 0.10*vec2(cos(t*0.38), sin(t*0.33));
      c += steer*0.55;

      float mu = julia(uv, c);

      // Normalize
      float n = mu / 52.0;                // iteration scale
      float core = smoothstep(0.0, 1.0, n);

      // Spectral “sheets” (abstract time-frequency vibe): banded interference, softened
      float sheets = 0.0;
      vec2 q = uv * 0.55;
      q += 0.12*vec2(sin(t*0.35), cos(t*0.27));
      float band = sin((q.y*9.0 + fbm(q*2.0)*2.0) + t*1.25);
      float band2 = sin((q.x*6.0 + fbm(q*1.6)*2.2) - t*1.05);
      sheets = 0.5 + 0.5*(band*0.65 + band2*0.35);
      sheets = smoothstep(0.15, 0.92, sheets) * 0.85;

      // Waveform-like ripples (subtle)
      float rip = sin((length(uv)*2.0 + fbm(uv*1.3))*3.2 - t*1.35);
      rip = 0.5 + 0.5*rip;
      rip = pow(rip, 2.2);

      // Color
      vec3 col = palette(0.16 + 0.85*n + 0.12*w1);
      col *= 0.55 + 0.65*sheets;
      col += vec3(0.25,0.35,0.55) * rip * 0.35;

      // Glow: emphasize edges where iteration changes
      float edge = fwidth(mu) * 1.2;
      float glow = exp(-8.0*abs(fract(mu*0.08) - 0.5));
      glow *= (0.35 + 0.65*sheets);
      col += glow * vec3(0.25,0.65,0.95) * 0.25;

      // Depth-like vignette + fog
      float v = smoothstep(1.35, 0.15, length((vUv*2.0-1.0)*vec2(res.x/res.y,1.0)));
      col *= (0.70 + 0.55*v);

      // Gentle dark floor
      col = mix(vec3(0.02,0.02,0.04), col, 0.98);

      // Dither to reduce banding (tiny)
      float d = (hash21(gl_FragCoord.xy) - 0.5) / 255.0;
      col += d;

      ${isWebGL2 ? "outColor = vec4(col, 1.0);" : "gl_FragColor = vec4(col, 1.0);"}
    }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      gl.deleteProgram(p);
      return null;
    }
    return p;
  }

  const vs = compile(gl.VERTEX_SHADER, VERT);
  const fs = compile(gl.FRAGMENT_SHADER, FRAG);
  const prog = link(vs, fs);
  gl.useProgram(prog);

  // Fullscreen quad
  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog, "aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  const uRes  = gl.getUniformLocation(prog, "iResolution");
  const uTime = gl.getUniformLocation(prog, "iTime");
  const uMouse= gl.getUniformLocation(prog, "iMouse");

  let DPR = 1, W=0, H=0;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0,0,W,H);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // Mouse (smoothed)
  let mx = innerWidth*0.5, my = innerHeight*0.5;
  let smx = mx, smy = my;
  addEventListener("pointermove", (e)=>{ mx=e.clientX; my=e.clientY; }, {passive:true});

  // Controls (optional, no text shown)
  addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if(k === "r"){
      // quick re-seed by nudging time base (visual change, no heavy rebuild)
      t0 = performance.now() - Math.random()*10000;
    }
  });

  // Smooth animation timing
  let t0 = performance.now();
  function draw(now){
    requestAnimationFrame(draw);

    // Smooth mouse
    smx += (mx - smx) * 0.09;
    smy += (my - smy) * 0.09;

    const t = (now - t0) / 1000;

    gl.useProgram(prog);
    gl.uniform2f(uRes, W, H);
    gl.uniform1f(uTime, t);
    gl.uniform2f(uMouse, smx * DPR, (innerHeight - smy) * DPR);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>

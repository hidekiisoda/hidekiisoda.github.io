<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="dark" />
<title>Dr. Hideki Isoda</title>
<style>
  :root{
    --bg:#05060a;
    --bg2:#070a12;
    --ink:rgba(235,240,255,.92);
    --sub:rgba(235,240,255,.62);
    --line:rgba(255,255,255,.10);
  }
  html,body{
    margin:0;height:100%;overflow:hidden;
    background:
      radial-gradient(900px 700px at 20% 10%, #0c1430 0%, transparent 60%),
      radial-gradient(900px 700px at 80% 15%, #2b1244 0%, transparent 60%),
      radial-gradient(900px 700px at 60% 90%, #0c2a35 0%, transparent 65%),
      linear-gradient(180deg,var(--bg),var(--bg2));
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  }
  canvas{ position:fixed; inset:0; width:100vw; height:100vh; display:block; }

  .hud{
    position:fixed; inset:0; pointer-events:none;
    display:grid; grid-template-rows:auto 1fr auto;
    padding:clamp(16px,2.2vw,30px);
  }
  .header{ display:flex; justify-content:space-between; align-items:flex-start; gap:20px; }
  .card{
    backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
    background:linear-gradient(90deg,rgba(255,255,255,.06),rgba(255,255,255,.015));
    border:1px solid var(--line);
    border-radius:18px; padding:14px 18px; max-width:820px;
    box-shadow: 0 18px 60px rgba(0,0,0,.35);
  }
  .card h1{
    margin:0;
    font-size:clamp(14px,1.9vw,18px);
    letter-spacing:.12em;
    font-weight:650;
    color:var(--ink);
    text-transform:uppercase;
  }
  .card p{
    margin:8px 0 0;
    font-size:clamp(12px,1.5vw,14px);
    color:var(--sub);
    line-height:1.4;
  }
  .signature{
    color:var(--sub);
    font-size:12px;
    letter-spacing:.1em;
    text-transform:uppercase;
    white-space:nowrap;
    padding-top:6px;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,.6));
  }

  .footer{
    display:flex; justify-content:space-between; align-items:flex-end; gap:16px;
    font-size:12px; color:var(--sub);
  }
  .controls{
    backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
    background:linear-gradient(90deg,rgba(255,255,255,.04),rgba(255,255,255,.01));
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px;
    padding:10px 14px;
  }
  kbd{
    font-family:ui-monospace,monospace;
    font-size:11px;
    padding:2px 6px;
    border-radius:7px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.25);
    color:var(--ink);
  }

  .site-link{ pointer-events:auto; font-size:11px; letter-spacing:.08em; text-transform:uppercase; }
  .site-link a{
    color:rgba(200,220,255,.65);
    text-decoration:none;
    border-bottom:1px solid rgba(200,220,255,.25);
    padding-bottom:2px;
  }
  .site-link a:hover{
    color:rgba(255,255,255,.9);
    border-bottom-color:rgba(255,255,255,.6);
  }

  .fx{
    position:fixed; inset:0; pointer-events:none;
    background:
      radial-gradient(1200px 900px at 50% 45%, transparent 45%, rgba(0,0,0,.50) 85%),
      repeating-linear-gradient(180deg, rgba(255,255,255,.016) 0px, rgba(255,255,255,.016) 1px, transparent 2px, transparent 5px);
    mix-blend-mode: overlay;
    opacity:.55;
  }

  @media (prefers-reduced-motion: reduce){
    .controls::after{ content:"  (Reduced Motion)"; opacity:.7; }
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div class="header">
    <div class="card">
      <h1>Music Informatics · Waveforms · Spectrogram · AI</h1>
      <p>
        A 3D-inspired motion study: time–frequency curtains, harmonic ribbons, and an embedding-like lattice —
        conducted by your cursor.
      </p>
    </div>
    <div class="signature">Dr. Hideki Isoda</div>
  </div>
  <div></div>
  <div class="footer">
    <div class="controls">
      <kbd>Space</kbd> pause · <kbd>R</kbd> reseed · <kbd>H</kbd> hide UI ·
      <kbd>S</kbd> snapshot · move cursor to conduct
    </div>
    <div class="site-link">
      <a href="https://hidekiisoda.com" target="_blank" rel="noopener">hidekiisoda.com</a>
    </div>
  </div>
</div>

<div class="fx"></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:true, desynchronized:true });

  // ----- DPI / Resize
  let W=0,H=0,DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(innerWidth);
    H = Math.floor(innerHeight);
    canvas.width = Math.floor(W*DPR);
    canvas.height = Math.floor(H*DPR);
    canvas.style.width = W+"px";
    canvas.style.height = H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // ----- RNG (xorshift32) for deterministic reseed
  let seed = (Date.now() ^ (Math.random()*1e9)) >>> 0;
  const rand = () => {
    seed ^= seed << 13; seed >>>= 0;
    seed ^= seed >> 17; seed >>>= 0;
    seed ^= seed << 5;  seed >>>= 0;
    return (seed>>>0)/4294967296;
  };
  const r = (a,b)=> a + (b-a)*rand();
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const smooth=(a,b,x)=>{ const t=clamp((x-a)/(b-a),0,1); return t*t*(3-2*t); };

  // ----- Interaction
  let mx=W*0.55, my=H*0.48, mvx=0, mvy=0, down=false;
  function pointer(x,y){
    mvx = x-mx; mvy = y-my;
    mx=x; my=y;
  }
  addEventListener("pointermove", e=>pointer(e.clientX,e.clientY), {passive:true});
  addEventListener("pointerdown", e=>{down=true; pointer(e.clientX,e.clientY);}, {passive:true});
  addEventListener("pointerup", ()=>{down=false;}, {passive:true});

  let paused=false, showHUD=true;

  // ----- 3D camera + projection
  // World units: centered around (0,0,0). Camera looks toward origin.
  const cam = { x:0, y:0, z: 780 };
  function project(P){
    // simple perspective
    const z = (P.z + cam.z);
    const f = 680 / Math.max(80, z); // focal-ish
    return {
      x: W*0.5 + P.x*f,
      y: H*0.5 + P.y*f,
      s: f,
      z: z
    };
  }

  // ----- Scene elements
  const STAR = 900;     // depth particles
  const NODE = 96;      // lattice nodes
  const stars = [];
  const nodes = [];
  const edges = [];     // edges are implicit; we'll draw by proximity

  // Spectrogram bins (curtain strips)
  const BINS = 180;
  const band = new Float32Array(BINS);

  function reseed(){
    seed = ((Date.now()*2654435761) ^ (Math.random()*1e9)) >>> 0;

    stars.length=0; nodes.length=0;

    // Starfield / grains in a volume
    for(let i=0;i<STAR;i++){
      stars.push({
        x:r(-520,520),
        y:r(-320,320),
        z:r(-260,680),
        vx:r(-0.05,0.05),
        vy:r(-0.05,0.05),
        hue:r(175,295),
        w:r(0.6,2.1)
      });
    }

    // Lattice nodes distributed in a loose 3D slab
    for(let i=0;i<NODE;i++){
      nodes.push({
        x:r(-420,420),
        y:r(-240,240),
        z:r(-120,520),
        vx:r(-0.10,0.10),
        vy:r(-0.10,0.10),
        vz:r(-0.06,0.06),
        hue:r(190,305),
        p:r(0,1)
      });
    }
  }
  reseed();

  // ----- Helpers (glow + strokes)
  function glowDot(x,y,radius, hue, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `hsla(${hue},95%,70%,1)`;
    ctx.shadowColor = `hsla(${hue},95%,70%,0.55)`;
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function softLine(x1,y1,x2,y2,w, hue, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = `hsla(${hue},95%,70%,1)`;
    ctx.lineWidth = w;
    ctx.lineCap = "round";
    ctx.shadowColor = `hsla(${hue},95%,70%,0.35)`;
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.restore();
  }

  function fogAlpha(z){
    // z is camera-space depth (bigger = farther)
    const near=220, far=1200;
    return 1 - smooth(near, far, z);
  }

  // ----- Main loop
  let t0=performance.now(), last=t0;
  const reduceMotion = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;

  function frame(now){
    requestAnimationFrame(frame);
    if(paused) return;

    // If reduced motion, effectively slow time progression
    const rawDt = Math.min(0.033, (now-last)/1000);
    last = now;
    const dt = reduceMotion ? rawDt*0.35 : rawDt;

    const t = (now - t0)/1000;
    const conduct = down ? 1.0 : 0.55;
    const vel = Math.hypot(mvx,mvy);
    const energy = clamp(vel/55, 0, 1) * conduct;

    // Camera orbit (subtle)
    const orbit = 0.35 + 0.40*energy;
    cam.x = Math.sin(t*0.18)*110*orbit;
    cam.y = Math.cos(t*0.14)*70*orbit;

    // Trails
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(4,6,10,0.12)";
    ctx.fillRect(0,0,W,H);

    // --- Build a “spectral” band array (cursor affects centroid)
    const cy = (my/H);
    for(let i=0;i<BINS;i++){
      const u = i/(BINS-1);
      const focus = Math.exp(-Math.pow(u - cy, 2) * 10.0);
      const n1 = Math.sin(t*0.9 + u*7.0 + Math.sin(t*0.35 + u*9.0)*0.7);
      const n2 = Math.sin(t*1.35 + u*15.0 + Math.cos(t*0.55 - u*6.0)*0.9);
      const n3 = Math.sin(t*0.22 + u*34.0);
      const a = 0.55 + 0.30*n1 + 0.18*n2 + 0.10*n3 + 0.25*focus*energy;
      band[i] = clamp(0.5 + 0.5*a, 0, 1);
    }

    // --- 3D Spectrogram curtain plane
    // Plane is a rotated slab in 3D; we draw vertical strips with height = band amplitude.
    ctx.globalCompositeOperation = "lighter";
    const plane = {
      z0: 240 + Math.sin(t*0.22)*55,
      width: 980,
      height: 520,
      tilt: 0.55 + Math.sin(t*0.12)*0.18, // rotation around Y
      roll: 0.08*Math.sin(t*0.17)         // slight roll
    };

    for(let i=0;i<BINS;i++){
      const u = (i/(BINS-1))*2 - 1; // -1..1 across plane width
      const amp = band[i];

      // 3D position of strip base center on plane
      // rotate around Y (tilt) and around Z (roll)
      const x0 = (u * plane.width*0.5);
      const y0 = 0;
      const z0 = plane.z0;

      const ct = Math.cos(plane.tilt), st = Math.sin(plane.tilt);
      let X = x0*ct + z0*st;
      let Z = -x0*st + z0*ct;

      const cr = Math.cos(plane.roll), sr = Math.sin(plane.roll);
      let Y = y0*cr - X*sr;
      X = y0*sr + X*cr;

      // strip height in world units
      const h = (0.10 + 0.90*amp) * plane.height;

      // top and bottom points in 3D
      const p1 = project({ x:X, y:Y - h*0.5, z:Z });
      const p2 = project({ x:X, y:Y + h*0.5, z:Z });

      // thickness based on depth
      const w = clamp(1.0*p1.s, 0.6, 2.8);
      const hue = 175 + 120*(i/(BINS-1)) + 50*Math.sin(t*0.18 + i*0.02);

      const a = (0.02 + 0.10*amp) * fogAlpha((p1.z+p2.z)*0.5);
      softLine(p1.x,p1.y,p2.x,p2.y,w,hue,a);
    }

    // --- Harmonic ribbon in 3D (polyline)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for(let rix=0; rix<3; rix++){
      const phase = t*0.65 + rix*1.2;
      const zBase = 60 + rix*110 + 50*Math.sin(t*0.12 + rix);
      const hue = 195 + rix*22 + 30*Math.sin(t*0.14 + rix);

      ctx.beginPath();
      let started=false;

      for(let i=0;i<=260;i++){
        const u = i/260;
        const x = (u*2-1) * 560;

        // sample band by screen-ish mapping
        const bi = Math.floor(clamp(u*(BINS-1), 0, BINS-1));
        const amp = band[bi];

        // waveform in Y + slight Z modulation for depth “twist”
        const y =
          Math.sin(phase + u*Math.PI*2*(2.0+rix*0.6))*55*(0.6+amp)
          + Math.sin(phase*1.6 + u*Math.PI*2*(3.4+rix*0.4))*24*(0.6+amp)
          + (my/H - 0.5)*80*energy;

        const z = zBase + Math.sin(phase*1.1 + u*6.0)*40*(0.5+amp) + 120*(0.5-amp);

        const p = project({x,y,z});
        if(!started){ ctx.moveTo(p.x,p.y); started=true; }
        else ctx.lineTo(p.x,p.y);
      }

      const alpha = 0.08 + 0.06*energy;
      ctx.strokeStyle = `hsla(${hue},95%,72%,${alpha})`;
      ctx.lineWidth = 1.3;
      ctx.shadowColor = `hsla(${hue},95%,72%,0.45)`;
      ctx.shadowBlur = 18;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    ctx.restore();

    // --- Lattice nodes in 3D (AI/graph feel)
    // Cursor pulls in world space: map cursor to target point near origin
    const target = {
      x: (mx/W - 0.5) * 220,
      y: (my/H - 0.5) * 160,
      z: 220 + 200*(0.5 - (my/H))
    };

    for(const n of nodes){
      // attraction to target
      const dx = n.x - target.x;
      const dy = n.y - target.y;
      const dz = n.z - target.z;
      const d = Math.hypot(dx,dy,dz) + 1e-6;

      const pull = smooth(520, 120, d) * (0.08 + 0.35*energy);
      n.vx += (-dx/d) * pull * conduct;
      n.vy += (-dy/d) * pull * conduct;
      n.vz += (-dz/d) * pull * conduct;

      // gentle drift
      n.vx += Math.sin(t*0.35 + n.p*9.0)*0.010;
      n.vy += Math.cos(t*0.28 + n.p*7.0)*0.010;
      n.vz += Math.sin(t*0.22 + n.p*8.0)*0.008;

      // damping
      n.vx *= 0.985;
      n.vy *= 0.985;
      n.vz *= 0.988;

      n.x += n.vx;
      n.y += n.vy;
      n.z += n.vz;

      // bounds
      n.x = clamp(n.x, -520, 520);
      n.y = clamp(n.y, -320, 320);
      n.z = clamp(n.z, -220, 720);
    }

    // Draw edges by proximity in 3D (projected)
    for(let i=0;i<nodes.length;i++){
      const a = nodes[i];
      const pa = project(a);
      const aa = fogAlpha(pa.z);
      for(let j=i+1;j<nodes.length;j++){
        const b = nodes[j];
        const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
        const d = Math.hypot(dx,dy,dz);
        if(d < 160){
          const pb = project(b);
          const bb = fogAlpha(pb.z);
          const alpha = (1 - d/160) * (0.020 + 0.070*energy) * Math.min(aa,bb);
          const hue = (a.hue+b.hue)*0.5 + 18*Math.sin(t*0.18);
          const w = clamp(0.9 * ((pa.s+pb.s)*0.5), 0.6, 1.8);
          softLine(pa.x,pa.y,pb.x,pb.y,w,hue,alpha);
        }
      }
    }

    // Draw nodes
    for(const n of nodes){
      const p = project(n);
      const hot = smooth(520, 120, Math.hypot(n.x-target.x, n.y-target.y, n.z-target.z)) * (0.4+0.6*energy);
      const alpha = (0.06 + 0.12*hot) * fogAlpha(p.z);
      const rad = clamp(1.0*p.s + 1.6*hot, 0.9, 4.2);
      glowDot(p.x,p.y,rad,n.hue,alpha);
    }

    // --- Star / grain volume (depth particles)
    for(const s of stars){
      // drift with slight curl + cursor energy
      const curl = Math.sin(t*0.5 + s.z*0.01) * 0.03;
      s.x += (s.vx + curl) * (1 + 0.7*energy);
      s.y += (s.vy - curl) * (1 + 0.7*energy);
      s.z += (-0.12 - 0.25*energy); // forward motion toward camera

      // wrap around volume
      if(s.x<-560) s.x=560; if(s.x>560) s.x=-560;
      if(s.y<-360) s.y=360; if(s.y>360) s.y=-360;
      if(s.z<-260) s.z=680;

      const p = project(s);
      const a = (0.02 + 0.08*(p.s)) * fogAlpha(p.z);
      const rad = clamp(s.w * (0.7 + 1.2*p.s), 0.5, 3.2);

      // hue subtly depends on depth
      const hue = s.hue + 25*Math.sin(t*0.12 + s.z*0.01);
      glowDot(p.x,p.y,rad,hue,a);
    }

    // --- Cursor halo (depthy)
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    const halo = 0.018 + 0.10*energy;
    const g = ctx.createRadialGradient(mx,my, 0, mx,my, 260);
    g.addColorStop(0, `rgba(255,255,255,${halo})`);
    g.addColorStop(0.25, `rgba(120,255,240,${halo*0.65})`);
    g.addColorStop(0.62, `rgba(180,120,255,${halo*0.45})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(mx,my, 260, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Init
  ctx.fillStyle = "rgba(4,6,10,1)";
  ctx.fillRect(0,0,W,H);
  requestAnimationFrame(frame);

  // Controls
  addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if(k===" "){ e.preventDefault(); paused=!paused; if(!paused) last=performance.now(); }
    else if(k==="r"){ reseed(); }
    else if(k==="h"){
      showHUD = !showHUD;
      document.querySelector(".hud").style.display = showHUD ? "grid" : "none";
    } else if(k==="s"){
      try{
        const a=document.createElement("a");
        a.download="music-informatics-3d.png";
        a.href=canvas.toDataURL("image/png");
        a.click();
      }catch(_){}
    }
  });
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="dark" />
<title>Dr. Hideki Isoda</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#05060a;}
  canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block;}
  .site-link{
    position:fixed; right:18px; bottom:16px; z-index:10;
    font: 11px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    letter-spacing:.08em; text-transform:uppercase;
    pointer-events:auto;
  }
  .site-link a{
    color:rgba(200,220,255,.70);
    text-decoration:none;
    border-bottom:1px solid rgba(200,220,255,.28);
    padding-bottom:2px;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,.55));
  }
  .site-link a:hover{
    color:rgba(255,255,255,.92);
    border-bottom-color:rgba(255,255,255,.65);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="site-link">
  <a href="https://hidekiisoda.com" target="_blank" rel="noopener">hidekiisoda.com</a>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const gl =
    canvas.getContext("webgl", { alpha:false, antialias:false, preserveDrawingBuffer:false }) ||
    canvas.getContext("experimental-webgl", { alpha:false, antialias:false, preserveDrawingBuffer:false });

  // Keep functional if WebGL is unavailable (no extra text).
  if (!gl) {
    const ctx = canvas.getContext("2d");
    const resize2D = () => {
      const dpr = Math.min(2, devicePixelRatio || 1);
      canvas.width = Math.floor(innerWidth*dpr);
      canvas.height = Math.floor(innerHeight*dpr);
      canvas.style.width = innerWidth+"px";
      canvas.style.height = innerHeight+"px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const g = ctx.createRadialGradient(innerWidth*0.35, innerHeight*0.25, 0, innerWidth*0.5, innerHeight*0.5, Math.max(innerWidth,innerHeight));
      g.addColorStop(0, "#141b40"); g.addColorStop(0.55, "#0b1024"); g.addColorStop(1, "#05060a");
      ctx.fillStyle = g; ctx.fillRect(0,0,innerWidth,innerHeight);
    };
    addEventListener("resize", resize2D, {passive:true}); resize2D();
    return;
  }

  const VERT = `
    attribute vec2 aPos;
    varying vec2 vUv;
    void main(){
      vUv = aPos * 0.5 + 0.5;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }
  `;

  // More “beautiful”: nebula-like fractal with:
  // - hybrid Mandelbrot/Julia (stable, smooth)
  // - orbit trap highlights (fine luminous filaments)
  // - domain-warped fbm (depth + softness)
  // - subtle chroma split + glow
  const FRAG = `
    precision highp float;
    varying vec2 vUv;
    uniform vec2  iResolution;
    uniform float iTime;
    uniform vec2  iMouse;

    // --- tiny hash/noise/fbm
    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f*f*(3.0-2.0*f);
      float a = hash12(i);
      float b = hash12(i + vec2(1.0,0.0));
      float c = hash12(i + vec2(0.0,1.0));
      float d = hash12(i + vec2(1.0,1.0));
      return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
    }

    float fbm(vec2 p){
      float v = 0.0;
      float a = 0.55;
      mat2 m = mat2(1.62,1.18,-1.18,1.62);
      for(int i=0;i<6;i++){
        v += a * noise(p);
        p = m*p + 0.11;
        a *= 0.5;
      }
      return v;
    }

    mat2 rot(float a){
      float s = sin(a), c = cos(a);
      return mat2(c,-s,s,c);
    }

    // Inigo Quilez-ish palette (soft, high-end)
    vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){
      return a + b*cos(6.28318*(c*t + d));
    }

    // Hybrid fractal: returns (smooth iters, trap)
    vec2 hybridFractal(vec2 z0, vec2 cM, vec2 cJ){
      vec2 z = z0;
      float m2 = dot(z,z);
      float it = 0.0;

      // orbit trap: distance to a moving line + circle
      float trap = 1e9;
      vec2 lineN = normalize(vec2(0.8 + 0.2*sin(iTime*0.25), 0.6 + 0.2*cos(iTime*0.21)));
      float lineD = 0.15 + 0.08*sin(iTime*0.17);

      for(int i=0;i<140;i++){
        // blend Mandelbrot and Julia behavior smoothly
        vec2 c = mix(cM, cJ, 0.52 + 0.48*sin(iTime*0.12));
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;

        // orbit trap update
        float dl = abs(dot(z, lineN) - lineD);
        float dc = abs(length(z) - (0.55 + 0.10*sin(iTime*0.33)));
        trap = min(trap, min(dl, dc));

        m2 = dot(z,z);
        if(m2 > 64.0){
          it = float(i);
          break;
        }
        it = float(i);
      }

      // smooth iteration count
      float mu = it;
      if(m2 > 0.0){
        mu = it - log2(log2(max(1.0001, m2)));
      }

      return vec2(mu, trap);
    }

    void main(){
      vec2 res = iResolution;
      vec2 uv = vUv*2.0 - 1.0;
      uv.x *= res.x / max(1.0, res.y);

      // smoothed mouse steering
      vec2 m = iMouse / max(res, vec2(1.0));
      vec2 steer = (m - 0.5) * vec2(0.55, 0.36);

      float t = iTime;

      // Camera-ish motion (smooth, not slow)
      float r0 = 0.10*sin(t*0.75) + 0.06*cos(t*0.53);
      uv = rot(r0) * uv;

      // “Beauty” comes from layered warps + coherent motion
      float zoom = 1.18 + 0.16*sin(t*0.55);
      vec2 p = uv * zoom;

      // Fractal-on-fractal domain warp (adds depth + softness)
      float w1 = fbm(p*1.10 + vec2( 0.14*t, -0.09*t));
      float w2 = fbm(p*2.10 + vec2(-0.10*t,  0.12*t));
      vec2 warp = vec2(w1-0.5, w2-0.5);
      p += warp * (0.62 + 0.14*sin(t*0.40));

      // A second warp layer (subtle) for “volumetric” feel
      vec2 p2 = p + 0.25*vec2(sin(t*0.25), cos(t*0.22));
      float w3 = fbm(p2*3.0 + vec2(0.07*t, -0.06*t));
      p += (w3-0.5) * vec2(0.22, -0.18);

      // Fractal parameters
      vec2 cM = vec2(-0.72, 0.12) + 0.10*vec2(cos(t*0.32), sin(t*0.28)) + steer*0.55;
      vec2 cJ = vec2(-0.18, 0.66) + 0.12*vec2(cos(t*0.41), sin(t*0.36)) - steer*0.40;

      // Chromatic micro-shift (subtle)
      vec2 ca = 0.006 * vec2(cos(t*0.6), sin(t*0.55));
      vec2 frA = hybridFractal(p + ca, cM, cJ);
      vec2 frB = hybridFractal(p,      cM, cJ);
      vec2 frC = hybridFractal(p - ca, cM, cJ);

      float mu = frB.x;
      float n  = clamp(mu / 56.0, 0.0, 1.0);

      // Trap glow (filaments)
      float trap = frB.y;
      float fil  = exp(-18.0*trap);
      fil *= (0.45 + 0.55*smoothstep(0.05, 1.0, n));

      // Soft “spectral sheets” (implied spectrogram)
      vec2 q = uv*0.90 + warp*0.45;
      float sh1 = sin(q.y*7.2 + fbm(q*1.8)*2.4 + t*2.8);
      float sh2 = sin(q.x*5.4 + fbm(q*1.4)*2.0 - t*2.4);
      float sheets = 0.5 + 0.5*(sh1*0.62 + sh2*0.38);
      sheets = smoothstep(0.18, 0.96, sheets);

      // “Waveform” rings (very gentle)
      float rr = length(uv);
      float rings = 0.5 + 0.5*sin((rr*2.2 + fbm(uv*1.2))*3.8 - t*2.9);
      rings = pow(rings, 2.6);

      // Color: three-channel n for gentle chroma depth
      float nR = clamp(frA.x / 56.0, 0.0, 1.0);
      float nG = n;
      float nB = clamp(frC.x / 56.0, 0.0, 1.0);

      vec3 base = pal(
        0.10 + 0.95*nG + 0.08*w1,
        vec3(0.06,0.08,0.14),
        vec3(0.62,0.44,0.82),
        vec3(1.00,0.98,0.92),
        vec3(0.18,0.30,0.52)
      );

      // Subtle per-channel shading (adds “3D” richness)
      vec3 chan = vec3(nR, nG, nB);
      base *= (0.78 + 0.22*chan);

      // Nebula body
      vec3 col = base;
      col *= (0.55 + 0.70*sheets);
      col += vec3(0.16,0.34,0.62) * rings * 0.22;

      // Filament glow (the “pretty” part)
      col += fil * vec3(0.35, 0.85, 1.10) * 0.32;
      col += fil * fil * vec3(1.00, 0.70, 0.95) * 0.10;

      // Smooth edge glow without harsh outlines
      float glow = exp(-7.0*abs(fract(mu*0.085) - 0.5));
      col += glow * vec3(0.18,0.60,0.95) * (0.10 + 0.22*sheets);

      // Vignette / depth
      float v = smoothstep(1.55, 0.08, length((vUv*2.0-1.0)*vec2(res.x/max(1.0,res.y),1.0)));
      col *= (0.70 + 0.62*v);

      // Gentle film grain (tiny)
      float d = (hash12(gl_FragCoord.xy + t*17.0) - 0.5) / 255.0;
      col += d;

      // Rich blacks
      col = mix(vec3(0.02,0.02,0.04), col, 0.985);

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(p));
      gl.deleteProgram(p);
      return null;
    }
    return p;
  }

  const vs = compile(gl.VERTEX_SHADER, VERT);
  const fs = compile(gl.FRAGMENT_SHADER, FRAG);
  if(!vs || !fs) return;

  const prog = link(vs, fs);
  if(!prog) return;
  gl.useProgram(prog);

  // Fullscreen quad
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog, "aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  const uRes   = gl.getUniformLocation(prog, "iResolution");
  const uTime  = gl.getUniformLocation(prog, "iTime");
  const uMouse = gl.getUniformLocation(prog, "iMouse");

  // Resize
  let DPR=1, w=0, h=0;
  function resize(){
    DPR = Math.min(2, devicePixelRatio || 1);
    w = Math.floor(innerWidth * DPR);
    h = Math.floor(innerHeight * DPR);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0, 0, w, h);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // Mouse smoothing (keeps motion “silk”)
  let mx = innerWidth*0.5, my = innerHeight*0.5;
  let smx = mx, smy = my;
  addEventListener("pointermove", (e)=>{ mx=e.clientX; my=e.clientY; }, {passive:true});

  // Animation
  let t0 = performance.now();
  function draw(now){
    requestAnimationFrame(draw);

    // smooth mouse
    smx += (mx - smx) * 0.10;
    smy += (my - smy) * 0.10;

    const t = (now - t0) / 1000;

    gl.uniform2f(uRes, w, h);
    gl.uniform1f(uTime, t);

    // Flip Y for intuitive feel
    gl.uniform2f(uMouse, smx * DPR, (innerHeight - smy) * DPR);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
